package net.akami.atosym.merge;

import net.akami.atosym.merge.property.OverallMergeProperty;

import java.util.List;
import java.util.Optional;
import java.util.function.Supplier;

/**
 * A behavior that takes two entries of the same type, and outputs a result that may or may not be of the same type. <br>
 * Outputs are by default calculated using {@link OverallMergeProperty} objects. These properties check one by one
 * whether they can produce a result from the two inputs given, and return this result is suitable. If no property
 * matches the two inputs, an error is automatically thrown. <br>
 * If there is only one property that can be applied to any pair of input, use {@code Collections.singletonList(property)}. <br>
 *
 * The merge method takes a boolean in parameter, which defines whether the object is being merged with itself. This is
 * only useful through redefinitions of the {@link #merge(Object, Object, boolean)} method, such as {@link FairSequencedMerge}. If
 * your method is not redefined, the value passed in parameter will not be taken into account.
 * @param <T> the input type used
 * @param <R> the result type, might or might not be the same as the input type
 *
 * @see FairMerge
 * @see FairSequencedMerge
 * @author Antoine Tran
 */
public interface Merge<T, R> {

    /**
     * Computes a result from the two input given. <br>
     * By default, goes through the different {@link OverallMergeProperty}
     * generated by the {@link #generateOverallProperties(Object, Object)} method, and returns
     * {@link OverallMergeProperty#rawComputeResult()} from the first property suiting the two inputs (checked via
     * {@link OverallMergeProperty#prepare()}. The boolean parameter is only used through redefinitions of this
     * method, see {@link FairSequencedMerge} for a concrete example.
     *
     * @param p1 the first input
     * @param p2 the second input
     * @param selfMerge whether a single input corresponds to both {@code p1} and {@code p2} parameters
     * @return a computed result from the two inputs given, according to the overall properties (by default)
     */
    default R merge(T p1, T p2, boolean selfMerge) {
        Supplier<IllegalStateException> exception = () -> new IllegalStateException("Could not find a property matching the two inputs. " +
                "If the merge behavior you are currently using doesn't directly or doesn't only use overall properties, you might need " +
                "to override the merge method");
        return resultFromProperties(p1, p2).orElseThrow(exception);
    }

    default Optional<R> resultFromProperties(T p1, T p2) {
        for(OverallMergeProperty<T, R> property : generateOverallProperties(p1, p2)) {
            if(property.prepare()) return Optional.of(property.rawComputeResult());
        }
        return Optional.empty();
    }

    /**
     * Generates a list of properties from the given input. <br>
     * Every time a merge occurs, a new list of properties must be generated. The reason for that is that these properties
     * might handle different fields that depend on the constructor parameters (the two inputs). Using setters instead of
     * re-instantiating new properties is also not recommended, since a property might recursively use itself, and change
     * the value of the inputs before the end of the calculation of the result. If you are guaranteed that recursive usage will not
     * happen, you might consider adding setters to your properties instead and always return the same list.
     * @param p1 the first input
     * @param p2 the second input
     * @return a list of properties constructed from the two inputs
     */
    List<? extends OverallMergeProperty<T, R>> generateOverallProperties(T p1, T p2);
}
