package net.akami.atosym.merge;

import net.akami.atosym.merge.property.OverallMergeProperty;

import java.util.List;

/**
 * A behavior that takes two entries of the same type, and outputs a result that may or may not be of the same type. <br>
 * Outputs are by default calculated using {@link OverallMergeProperty} objects. These properties check one by one
 * whether they can produce a result from the two inputs given, and return this result is suitable. If no property
 * matches the two inputs, an error is automatically thrown. <br>
 * If there is only one property that can be applied to any pair of input, use {@code Collections.singletonList(property)}. <br>
 *
 * The merge method takes a boolean in parameter, which defines whether the object is being merged with itself. This is
 * only useful through redefinitions of the {@link #merge(Object, Object, boolean)} method, such as {@link SequencedMerge}. If
 * your method is not redefined, the value passed in parameter will not be taken into account.
 * @param <P> the input type used
 * @param <R> the result type, might or might not be the same as the input type
 * @param <PROP> the type of {@link OverallMergeProperty} handled
 *
 * @see FairMerge
 * @see SequencedMerge
 * @author Antoine Tran
 */
public interface Merge<P, R, PROP extends OverallMergeProperty<P, R>> {

    /**
     * Computes a result from the two input given. <br>
     * By default, goes through the different {@link OverallMergeProperty}
     * generated by the {@link #generateOverallProperties(Object, Object)} method, and returns
     * {@link OverallMergeProperty#computeResult()} from the first property suiting the two inputs (checked via
     * {@link OverallMergeProperty#prepare()}. The boolean parameter is only used through redefinitions of this
     * method, see {@link SequencedMerge} for a concrete example.
     *
     * @param p1 the first input
     * @param p2 the second input
     * @param selfMerge whether a single input corresponds to both {@code p1} and {@code p2} parameters
     * @return a computed result from the two inputs given, according to the overall properties (by default)
     */
    default R merge(P p1, P p2, boolean selfMerge) {
        for(PROP property : generateOverallProperties(p1, p2)) {
            if(property.prepare()) return property.rawComputeResult();
        }

        throw new IllegalStateException("Could not find a property matching the two inputs. If the merge behavior you are " +
                "currently using doesn't directly or doesn't only use overall properties, you might need to override" +
                "the merge method");
    }

    /**
     * Generates a list of properties from the given input. <br>
     * Every time a merge occurs, a new list of properties must be generated. The reason for that is that these properties
     * might handle different fields that depend on the constructor parameters (the two inputs). Using setters instead of
     * re-instantiating new properties is also not recommended, since a property might recursively use itself, and change
     * the value of the inputs before the end of the calculation of the result. If you are guaranteed that recursive usage will not
     * happen, you might consider adding setters to your properties instead and always return the same list.
     * @param p1 the first input
     * @param p2 the second input
     * @return a list of properties constructed from the two inputs
     */
    List<PROP> generateOverallProperties(P p1, P p2);
}
